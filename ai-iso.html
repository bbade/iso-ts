<!DOCTYPE html>
<html>
<head>
<title>Isometric Stacked Tiles with Texture Upload and Bulk Edit</title>
<style>
  canvas {
    border: 1px solid black;
    cursor: pointer;
  }
  #buttons {
    margin-top: 10px;
  }
  button {
    margin-right: 10px;
  }
</style>
</head>
<body>

<canvas id="myCanvas" width="1024" height="1024"></canvas>

<div id="buttons">
    <input type="file" id="textureUpload" accept="image/png" style="display: none;">
    <button id="uploadButton">Upload Texture</button>
    <button id="resetButton">Reset</button>
</div>

<script>
  const TILE_WIDTH = 32;
  const TILE_HEIGHT = 16;

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");

  let board = []; // Will be initialized dynamically
  let highlightedTile = null;
  let usingTexture = false;
  let textureCanvas = null;
  let textureCtx = null;

    function initializeBoard(width, height) {
      board = [];
      for (let y = 0; y < height; y++) {
        let row = [];
        for (let x = 0; x < width; x++) {
          row.push(0); // Initialize all elevations to 0
        }
        board.push(row);
      }
    }
  //Initial 16x16 board
  initializeBoard(16,16);

  function getColorByElevation(elevation) {
    switch (elevation) {
      case 0: return "#0000ff"; // blue (water)
      case 1: return "#ffff00"; // yellow (sandy)
      case 2: case 3: return "#00c800"; // green (grass)
      case 4: case 5: return "#808080"; // gray (mountain)
      case 6: return "#ffffff"; // white (snow)
      default: return "#808080";
    }
  }

    function getTextureColor(boardX, boardY) {
        if (!textureCtx) {
          return "#000000"; // Default color if no texture
        }
        const pixelData = textureCtx.getImageData(boardX, boardY, 1, 1).data;
        return `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
    }


  function drawTile(boardX, boardY, zHeight, color, context, isHighlighted) {
    const isoX = (boardX - boardY) * TILE_WIDTH / 2;
    const isoY = (boardX + boardY) * TILE_HEIGHT / 2;
    const topOffsetY = -zHeight * TILE_HEIGHT;

    // Calculate vertices
    const v1x = isoX;
    const v1y = isoY + topOffsetY;
    const v2x = isoX + TILE_WIDTH / 2;
    const v2y = isoY + TILE_HEIGHT / 2 + topOffsetY;
    const v3x = isoX;
    const v3y = isoY + TILE_HEIGHT + topOffsetY;
    const v4x = isoX - TILE_WIDTH / 2;
    const v4y = isoY + TILE_HEIGHT / 2 + topOffsetY;
    const v5y = isoY + TILE_HEIGHT;

    let drawColor = color;
    if (isHighlighted) {
        drawColor = adjustBrightness(color, 0.2); // Brighten for highlight
    }

    // --- Top Face ---
    context.fillStyle = drawColor;
    context.beginPath();
    context.moveTo(v1x, v1y);
    context.lineTo(v2x, v2y);
    context.lineTo(v3x, v3y);
    context.lineTo(v4x, v4y);
    context.closePath();
    context.fill();

    // --- Left & Right Faces (only if zHeight > 0) ---
    if (zHeight > 0) {
        // --- Left Face ---
        context.fillStyle = adjustBrightness(drawColor, -0.2);
        context.beginPath();
        context.moveTo(v4x, v4y);
        context.lineTo(v3x, v3y);
        context.lineTo(v1x, v5y);
        context.lineTo(v4x, v4y + TILE_HEIGHT);
        context.closePath();
        context.fill();

        // --- Right Face ---
        context.fillStyle = adjustBrightness(drawColor, -0.4);
        context.beginPath();
        context.moveTo(v2x, v2y);
        context.lineTo(v3x, v3y);
        context.lineTo(v1x, v5y);
        context.lineTo(v2x, v2y + TILE_HEIGHT);
        context.closePath();
        context.fill();
    }
  }

  function adjustBrightness(color, amount) {
     // Handle rgb() colors
    if (color.startsWith("rgb")) {
        let [r, g, b] = color.substring(4, color.length - 1).split(",").map(Number);

        r = Math.min(255, Math.max(0, Math.round(r + amount * 255)));
        g = Math.min(255, Math.max(0, Math.round(g + amount * 255)));
        b = Math.min(255, Math.max(0, Math.round(b + amount * 255)));

        return `rgb(${r}, ${g}, ${b})`;
    }
    //Handle hex
    let usePound = false;
    if (color[0] == "#") {
        color = color.slice(1);
        usePound = true;
    }

    let num = parseInt(color, 16);
    let r = (num >> 16) + amount * 255;
    if (r > 255) r = 255;
    else if (r < 0) r = 0;
    let b = ((num >> 8) & 0x00FF) + amount * 255;
    if (b > 255) b = 255;
    else if (b < 0) b = 0;
    let g = (num & 0x0000FF) + amount * 255;
    if (g > 255) g = 255;
    else if (g < 0) g = 0;

    let newColor = (g | (b << 8) | (r << 16)).toString(16);

    while(newColor.length < 6){
        newColor = "0" + newColor;
    }

    return (usePound ? "#" : "") + newColor;

  }

  function screenToIso(screenX, screenY, offsetX, offsetY) {
    const isoX = screenX - offsetX;
    const isoY = screenY - offsetY;
    const boardX = (isoX / (TILE_WIDTH / 2) + isoY / (TILE_HEIGHT / 2)) / 2;
    const boardY = (isoY / (TILE_HEIGHT / 2) - isoX / (TILE_WIDTH / 2)) / 2;
    return { x: boardX, y: boardY };
  }

 function drawScene(context) {
    const offsetX = canvas.width / 2;  // Store offsets for clearing
    const offsetY = 350;
    for (let boardY = 0; boardY < board.length; boardY++) {
        for (let boardX = 0; boardX < board[boardY].length; boardX++) {
            const elevation = board[boardY][boardX];
            let tileColor;

            if (usingTexture) {
                tileColor = getTextureColor(boardX, boardY);
            } else {
                tileColor = getColorByElevation(elevation);
            }

            const isHighlighted = highlightedTile && highlightedTile.x === boardX && highlightedTile.y === boardY;

            for (let i = 0; i < elevation; i++) {
              drawTile(boardX, boardY, i, tileColor, context, isHighlighted);
            }
            if (elevation === 0) {
              drawTile(boardX, boardY, 0, tileColor, context, isHighlighted);
            }
        }
    }
}

  // --- Mouse Event Handlers ---
  canvas.addEventListener("click", function(event) {
    handleMouseClick(event, 1, false); // Left click, no shift
  });

  canvas.addEventListener("contextmenu", function(event) {
    event.preventDefault();
    handleMouseClick(event, -1, false); // Right click, no shift
  });

   canvas.addEventListener("mousemove", function(event) {
        handleMouseMove(event);
    });
    canvas.addEventListener("mouseout", function(event) {
        highlightedTile = null;
        const offsetX = canvas.width/2;
        const offsetY = 350;
        ctx.clearRect(-offsetX, -offsetY, canvas.width, canvas.height);
        drawScene(ctx);
    });


    function handleMouseClick(event, heightChange, isShiftClick) {
        const rect = canvas.getBoundingClientRect();
        const offsetX = canvas.width / 2;
        const offsetY = 350;
        const screenX = event.clientX - rect.left;
        const screenY = event.clientY - rect.top;
        let isoCoords = screenToIso(screenX, screenY, offsetX, offsetY);
        let clickedBoardX, clickedBoardY;

        for (let boardY = board.length - 1; boardY >= 0; boardY--) {
            for (let boardX = board[boardY].length - 1; boardX >= 0; boardX--) {
                const elevation = board[boardY][boardX];

                for (let i = elevation - 1; i >= 0; i--) {
                    const isoX = (boardX - boardY) * TILE_WIDTH / 2;
                    const isoY = (boardX + boardY) * TILE_HEIGHT / 2 - i * TILE_HEIGHT;

                    ctx.beginPath();
                    ctx.moveTo(isoX, isoY);
                    ctx.lineTo(isoX + TILE_WIDTH / 2, isoY + TILE_HEIGHT / 2);
                    ctx.lineTo(isoX, isoY + TILE_HEIGHT);
                    ctx.lineTo(isoX - TILE_WIDTH / 2, isoY + TILE_HEIGHT / 2);
                    ctx.closePath();

                    if (ctx.isPointInPath(screenX, screenY)) {
                        clickedBoardX = boardX;
                        clickedBoardY = boardY;
                         if (usingTexture && event.shiftKey) {
                            // Bulk edit
                            const targetColor = getTextureColor(clickedBoardX, clickedBoardY);
                            for (let y = 0; y < board.length; y++) {
                                for (let x = 0; x < board[y].length; x++) {
                                    if (getTextureColor(x, y) === targetColor) {
                                        board[y][x] = Math.max(0, board[y][x] + heightChange);
                                    }
                                }
                            }
                        } else {
                            // Single tile edit
                            console.log("Clicked tile: boardX =", clickedBoardX, ", boardY =", clickedBoardY, ", elevation =", elevation);
                            board[clickedBoardY][clickedBoardX] += heightChange;
                            board[clickedBoardY][clickedBoardX] = Math.max(0, board[clickedBoardY][clickedBoardX]);

                        }
                        ctx.clearRect(-offsetX, -offsetY, canvas.width, canvas.height);
                        drawScene(ctx);
                        return;

                    }
                }
                if(elevation == 0){ //check if it's a zero height
                    const isoX = (boardX-boardY) * TILE_WIDTH/2;
                    const isoY = (boardX+boardY) * TILE_HEIGHT/2;
                    ctx.beginPath();
                    ctx.moveTo(isoX, isoY);
                    ctx.lineTo(isoX + TILE_WIDTH/2, isoY + TILE_HEIGHT/2);
                    ctx.lineTo(isoX, isoY + TILE_HEIGHT);
                    ctx.lineTo(isoX - TILE_WIDTH/2, isoY + TILE_HEIGHT/2);
                    ctx.closePath();

                    if(ctx.isPointInPath(screenX, screenY)){
                        clickedBoardX = boardX;
                        clickedBoardY = boardY;

                        if (usingTexture && event.shiftKey) {
                            // Bulk edit
                            const targetColor = getTextureColor(clickedBoardX, clickedBoardY);
                            for (let y = 0; y < board.length; y++) {
                                for (let x = 0; x < board[y].length; x++) {
                                    if (getTextureColor(x, y) === targetColor) {
                                        board[y][x] = Math.max(0, board[y][x] + heightChange);
                                    }
                                }
                            }
                        } else {
                             console.log("Clicked tile: boardX =", clickedBoardX, ", boardY =", clickedBoardY, ", elevation =", elevation);
                            //single tile edit
                            board[clickedBoardY][clickedBoardX] += heightChange;
                            board[clickedBoardY][clickedBoardX] = Math.max(0, board[clickedBoardY][clickedBoardX]);
                        }

                        ctx.clearRect(-offsetX, -offsetY, canvas.width, canvas.height);
                        drawScene(ctx);
                        return;
                    }
                }
            }
        }
    }
  function handleMouseMove(event) {
    const rect = canvas.getBoundingClientRect();
    const offsetX = canvas.width / 2; // Cached offset
    const offsetY = 350;
    const screenX = event.clientX - rect.left;
    const screenY = event.clientY - rect.top;
    let isoCoords = screenToIso(screenX, screenY, offsetX, offsetY);
    let newHighlightedTile = null;

    // Iterate in reverse draw order (top-down) to find hovered tile
      for (let boardY = board.length - 1; boardY >= 0; boardY--) {
          for (let boardX = board[boardY].length - 1; boardX >= 0; boardX--) {
            const elevation = board[boardY][boardX];

              for(let i = elevation - 1; i>=0; i--){
                  const isoX = (boardX - boardY) * TILE_WIDTH / 2;
                  const isoY = (boardX + boardY) * TILE_HEIGHT / 2 - i * TILE_HEIGHT;

                  ctx.beginPath();
                  ctx.moveTo(isoX, isoY);
                  ctx.lineTo(isoX + TILE_WIDTH / 2, isoY + TILE_HEIGHT / 2);
                  ctx.lineTo(isoX, isoY + TILE_HEIGHT);
                  ctx.lineTo(isoX - TILE_WIDTH / 2, isoY + TILE_HEIGHT / 2);
                  ctx.closePath();

                  if (ctx.isPointInPath(screenX, screenY)) {
                    newHighlightedTile = { x: boardX, y: boardY };
                      break; // Stop checking other tiles in this stack
                  }
              }
              if(elevation == 0){
                  const isoX = (boardX - boardY) * TILE_WIDTH/2;
                    const isoY = (boardX + boardY) * TILE_HEIGHT/2;
                    ctx.beginPath();
                    ctx.moveTo(isoX, isoY);
                    ctx.lineTo(isoX + TILE_WIDTH/2, isoY+TILE_HEIGHT/2);
                    ctx.lineTo(isoX, isoY + TILE_HEIGHT);
                    ctx.lineTo(isoX - TILE_WIDTH/2, isoY+TILE_HEIGHT/2);
                    ctx.closePath();
                    if(ctx.isPointInPath(screenX, screenY)){
                        newHighlightedTile = {x:boardX, y:boardY};
                    }
              }
              if(newHighlightedTile)
                break;
          }
          if(newHighlightedTile)
            break;
      }

    if (newHighlightedTile && (!highlightedTile || newHighlightedTile.x !== highlightedTile.x || newHighlightedTile.y !== highlightedTile.y)) {
        // Highlight changed
        highlightedTile = newHighlightedTile;
        ctx.clearRect(-offsetX, -offsetY, canvas.width, canvas.height);  // Use cached offset
        drawScene(ctx);

      } else if (!newHighlightedTile && highlightedTile) {
        // No longer hovering over any tile
        highlightedTile = null;
        ctx.clearRect(-offsetX, -offsetY, canvas.width, canvas.height); // Use cached offset
        drawScene(ctx);
    }
  }

    // --- Texture Upload ---
    const uploadButton = document.getElementById("uploadButton");
    const textureUpload = document.getElementById("textureUpload");
    const resetButton = document.getElementById("resetButton");

    uploadButton.addEventListener("click", () => {
        textureUpload.click(); // Trigger the file input
    });

    textureUpload.addEventListener("change", function(event) {
        const file = event.target.files[0];
        if (file && file.type === "image/png") {
          const reader = new FileReader();
          reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
              // Create offscreen canvas
              textureCanvas = document.createElement("canvas");
              textureCanvas.width = img.width;
              textureCanvas.height = img.height;
              textureCtx = textureCanvas.getContext("2d");
              textureCtx.drawImage(img, 0, 0);

              // Resize and reset the board
              initializeBoard(img.width, img.height);
              usingTexture = true;

              // Redraw the scene
              const offsetX = canvas.width / 2;  // Get offsets for clearing
              const offsetY = 350;
                ctx.clearRect(-offsetX, -offsetY, canvas.width, canvas.height);
              drawScene(ctx);
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        } else {
            alert("Please upload a PNG image.");
        }
    });

    resetButton.addEventListener("click", () => {
        usingTexture = false;
        textureCanvas = null;
        textureCtx = null;
        initializeBoard(16,16); // Reset to original 16x16 board

        const offsetX = canvas.width / 2;
        const offsetY = 350;
        ctx.clearRect(-offsetX, -offsetY, canvas.width, canvas.height);
        drawScene(ctx);

        // Reset the file input (so the same file can be selected again)
        textureUpload.value = "";
    });


  // Error handling and initialization
  if (ctx) {
    ctx.translate(canvas.width / 2, 350); // Adjust for larger board
    drawScene(ctx);
  } else {
    console.error("Canvas not supported!");
    const canvasContainer = document.getElementById("myCanvas");
    canvasContainer.parentNode.replaceChild(
      document.createTextNode("Your browser does not support the canvas element."),
      canvasContainer
    );
  }
</script>

</body>
</html>