{"mappings":"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","sources":["<anon>","src/index.ts","src/buttons.ts","src/world.ts","src/render.ts","src/mouse.ts"],"sourcesContent":["// src/index.ts\n// World.ts\nconst $3aec07e3cb255787$var$World = {\n    board: [],\n    textureCanvas: null,\n    textureCtx: null,\n    usingTexture: false,\n    initializeBoard (width, height) {\n        this.board = [];\n        for(let y = 0; y < height; y++){\n            let row = [];\n            for(let x = 0; x < width; x++)row.push(0); // Initialize all elevations to 0\n            this.board.push(row);\n        }\n    },\n    getTile (boardX, boardY) {\n        if (boardX >= 0 && boardX < this.board[0].length && boardY >= 0 && boardY < this.board.length) return this.board[boardY][boardX];\n        return null; // Or handle out-of-bounds differently\n    },\n    setTile (boardX, boardY, elevation) {\n        if (boardX >= 0 && boardX < this.board[0].length && boardY >= 0 && boardY < this.board.length) this.board[boardY][boardX] = elevation;\n    },\n    getPixel (boardX, boardY) {\n        if (!this.textureCtx) return \"#000000\"; // Default color if no texture\n        let texX = boardX;\n        let texY = boardY;\n        // Bounds Check\n        if (texX < 0 || texX >= this.textureCanvas.width || texY < 0 || texY >= this.textureCanvas.height) return \"#000000\"; //Return black if out of bounds.\n        const pixelData = this.textureCtx.getImageData(texX, texY, 1, 1).data;\n        return `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;\n    },\n    setTexture (img) {\n        this.textureCanvas = document.createElement(\"canvas\");\n        this.textureCanvas.width = img.width;\n        this.textureCanvas.height = img.height;\n        this.textureCtx = this.textureCanvas.getContext(\"2d\"); // Assert non-null\n        this.textureCtx.drawImage(img, 0, 0);\n        this.usingTexture = true;\n        this.initializeBoard(img.width, img.height);\n    },\n    clearTexture () {\n        this.usingTexture = false;\n        this.textureCanvas = null;\n        this.textureCtx = null;\n    },\n    getWidth () {\n        return this.board[0].length;\n    },\n    getHeight () {\n        return this.board.length;\n    },\n    increaseElevation (boardX, boardY, bulkEdit) {\n        if (boardX >= 0 && boardX < this.getWidth() && boardY >= 0 && boardY < this.getHeight()) {\n            if (bulkEdit && this.usingTexture) {\n                const targetColor = this.getPixel(boardX, boardY);\n                for(let y = 0; y < this.getHeight(); y++){\n                    for(let x = 0; x < this.getWidth(); x++)if (this.getPixel(x, y) === targetColor) this.setTile(x, y, Math.max(0, this.getTile(x, y) + 1)); // Assert non-null\n                }\n            } else this.setTile(boardX, boardY, Math.max(0, this.getTile(boardX, boardY) + 1)); // Assert non-null\n        }\n    },\n    decreaseElevation (boardX, boardY, bulkEdit) {\n        if (boardX >= 0 && boardX < this.getWidth() && boardY >= 0 && boardY < this.getHeight()) {\n            if (bulkEdit && this.usingTexture) {\n                const targetColor = this.getPixel(boardX, boardY);\n                for(let y = 0; y < this.getHeight(); y++){\n                    for(let x = 0; x < this.getWidth(); x++)if (this.getPixel(x, y) === targetColor) this.setTile(x, y, Math.max(0, this.getTile(x, y) - 1)); // Assert non-null\n                }\n            } else this.setTile(boardX, boardY, Math.max(0, this.getTile(boardX, boardY) - 1)); // Assert non-null\n        }\n    },\n    rotateWorld (counterClockwise = false) {\n        // --- Rotate Texture (if using texture) ---\n        if (this.usingTexture && this.textureCanvas) {\n            const rotatedCanvas = document.createElement('canvas');\n            rotatedCanvas.width = this.textureCanvas.height; // Swap width/height\n            rotatedCanvas.height = this.textureCanvas.width;\n            const rotatedCtx = rotatedCanvas.getContext('2d'); // Assert non-null\n            rotatedCtx.clearRect(0, 0, rotatedCanvas.width, rotatedCanvas.height); //Clear\n            if (counterClockwise) {\n                rotatedCtx.rotate(-Math.PI / 2);\n                rotatedCtx.drawImage(this.textureCanvas, -this.textureCanvas.width, 0);\n            } else {\n                rotatedCtx.rotate(Math.PI / 2);\n                rotatedCtx.drawImage(this.textureCanvas, 0, -this.textureCanvas.height);\n            }\n            this.textureCanvas = rotatedCanvas; // Replace the old canvas\n            this.textureCtx = rotatedCtx;\n        }\n        // --- Rotate Board ---\n        let newBoard;\n        if (!counterClockwise) newBoard = this.board[0].map((val, index)=>this.board.map((row)=>row[index]).reverse());\n        else newBoard = this.board[0].map((val, index)=>this.board.map((row)=>row[row.length - 1 - index]));\n        this.board = newBoard; // Assign the new board\n    }\n};\n//Initial 16x16 board at startup\n$3aec07e3cb255787$var$World.initializeBoard(16, 16);\nvar $3aec07e3cb255787$export$2e2bcd8739ae039 = $3aec07e3cb255787$var$World;\n\n\n// render.ts\n\nconst $e3d6ee63ed1479b9$export$e11fadbd198f646b = 16;\nconst $e3d6ee63ed1479b9$export$fc29bff6b348510e = 8;\nconst $e3d6ee63ed1479b9$var$canvas = document.getElementById(\"myCanvas\");\nconst $e3d6ee63ed1479b9$var$ctx = $e3d6ee63ed1479b9$var$canvas.getContext(\"2d\"); // Assert non-null, checked below\n// Assuming highlightedTile is defined and managed in mouse.ts,\n// we'll declare it here with the correct type.  It's important\n// that this matches the type in mouse.ts.\nlet $e3d6ee63ed1479b9$var$highlightedTile = null; //From Mouse.js\nfunction $e3d6ee63ed1479b9$var$getColorByElevation(elevation) {\n    switch(elevation){\n        case 0:\n            return \"#0000ff\"; // blue (water)\n        case 1:\n            return \"#ffff00\"; // yellow (sandy)\n        case 2:\n        case 3:\n            return \"#00c800\"; // green (grass)\n        case 4:\n        case 5:\n            return \"#808080\"; // gray (mountain)\n        case 6:\n            return \"#ffffff\"; // white (snow)\n        default:\n            return \"#808080\";\n    }\n}\nfunction $e3d6ee63ed1479b9$var$tileVertices(boardX, boardY, zHeight) {\n    const isoX = (boardX - boardY) * $e3d6ee63ed1479b9$export$e11fadbd198f646b / 2;\n    const isoY = (boardX + boardY) * $e3d6ee63ed1479b9$export$fc29bff6b348510e / 2;\n    const topOffsetY = -zHeight * $e3d6ee63ed1479b9$export$fc29bff6b348510e;\n    return {\n        v1x: isoX,\n        v1y: isoY + topOffsetY,\n        v2x: isoX + $e3d6ee63ed1479b9$export$e11fadbd198f646b / 2,\n        v2y: isoY + $e3d6ee63ed1479b9$export$fc29bff6b348510e / 2 + topOffsetY,\n        v3x: isoX,\n        v3y: isoY + $e3d6ee63ed1479b9$export$fc29bff6b348510e + topOffsetY,\n        v4x: isoX - $e3d6ee63ed1479b9$export$e11fadbd198f646b / 2,\n        v4y: isoY + $e3d6ee63ed1479b9$export$fc29bff6b348510e / 2 + topOffsetY,\n        v5y: isoY + $e3d6ee63ed1479b9$export$fc29bff6b348510e,\n        v6y: isoY + $e3d6ee63ed1479b9$export$fc29bff6b348510e / 2,\n        v7y: isoY + $e3d6ee63ed1479b9$export$fc29bff6b348510e / 2\n    };\n}\nfunction $e3d6ee63ed1479b9$var$drawTile(boardX, boardY, zHeight, color, context, isHighlighted) {\n    const { v1x: v1x, v1y: v1y, v2x: v2x, v2y: v2y, v3x: v3x, v3y: v3y, v4x: v4x, v4y: v4y, v5y: v5y, v6y: v6y, v7y: v7y } = $e3d6ee63ed1479b9$var$tileVertices(boardX, boardY, zHeight);\n    let drawColor = color;\n    if (isHighlighted) drawColor = $e3d6ee63ed1479b9$var$adjustBrightness(color, 0.2); // Brighten for highlight\n    // --- Top Face ---\n    context.fillStyle = drawColor;\n    $e3d6ee63ed1479b9$var$tilePath(context, v1x, v1y, v2x, v2y, v3x, v3y, v4x, v4y);\n    context.fill();\n    // --- Left & Right Faces (only if zHeight > 0) ---\n    if (zHeight > 0) {\n        // --- Left Face ---\n        context.fillStyle = $e3d6ee63ed1479b9$var$adjustBrightness(drawColor, -0.2);\n        context.beginPath();\n        context.moveTo(v4x, v4y);\n        context.lineTo(v3x, v3y);\n        context.lineTo(v1x, v5y);\n        context.lineTo(v4x, v6y);\n        context.closePath();\n        context.fill();\n        // --- Right Face ---\n        context.fillStyle = $e3d6ee63ed1479b9$var$adjustBrightness(drawColor, -0.4);\n        context.beginPath();\n        context.moveTo(v2x, v2y);\n        context.lineTo(v3x, v3y);\n        context.lineTo(v1x, v5y);\n        context.lineTo(v2x, v7y);\n        context.closePath();\n        context.fill();\n    }\n}\nfunction $e3d6ee63ed1479b9$var$tilePath(context, v1x, v1y, v2x, v2y, v3x, v3y, v4x, v4y) {\n    context.beginPath();\n    context.moveTo(v1x, v1y);\n    context.lineTo(v2x, v2y);\n    context.lineTo(v3x, v3y);\n    context.lineTo(v4x, v4y);\n    context.closePath();\n}\nfunction $e3d6ee63ed1479b9$var$adjustBrightness(color, amount) {\n    // Handle rgb() colors\n    if (color.startsWith(\"rgb\")) {\n        let [r, g, b] = color.substring(4, color.length - 1).split(\",\").map(Number);\n        r = Math.min(255, Math.max(0, Math.round(r + amount * 255)));\n        g = Math.min(255, Math.max(0, Math.round(g + amount * 255)));\n        b = Math.min(255, Math.max(0, Math.round(b + amount * 255)));\n        return `rgb(${r}, ${g}, ${b})`;\n    }\n    //Handle hex\n    let usePound = false;\n    if (color[0] == \"#\") {\n        color = color.slice(1);\n        usePound = true;\n    }\n    let num = parseInt(color, 16);\n    let r = (num >> 16) + amount * 255;\n    if (r > 255) r = 255;\n    else if (r < 0) r = 0;\n    let b = (num >> 8 & 0x00FF) + amount * 255;\n    if (b > 255) b = 255;\n    else if (b < 0) b = 0;\n    let g = (num & 0x0000FF) + amount * 255;\n    if (g > 255) g = 255;\n    else if (g < 0) g = 0;\n    let newColor = (g | b << 8 | r << 16).toString(16);\n    while(newColor.length < 6)newColor = \"0\" + newColor;\n    return (usePound ? \"#\" : \"\") + newColor;\n}\nfunction $e3d6ee63ed1479b9$var$screenToIso(screenX, screenY, offsetX, offsetY) {\n    const isoX = screenX - offsetX;\n    const isoY = screenY - offsetY;\n    const boardX = (isoX / ($e3d6ee63ed1479b9$export$e11fadbd198f646b / 2) + isoY / ($e3d6ee63ed1479b9$export$fc29bff6b348510e / 2)) / 2;\n    const boardY = (isoY / ($e3d6ee63ed1479b9$export$fc29bff6b348510e / 2) - isoX / ($e3d6ee63ed1479b9$export$e11fadbd198f646b / 2)) / 2;\n    return {\n        x: boardX,\n        y: boardY\n    };\n}\nfunction $e3d6ee63ed1479b9$var$drawScene(context) {\n    const offsetX = $e3d6ee63ed1479b9$var$canvas.width / 2;\n    const offsetY = 50;\n    for(let boardY = 0; boardY < (0, $3aec07e3cb255787$export$2e2bcd8739ae039).getHeight(); boardY++)for(let boardX = 0; boardX < (0, $3aec07e3cb255787$export$2e2bcd8739ae039).getWidth(); boardX++){\n        const elevation = (0, $3aec07e3cb255787$export$2e2bcd8739ae039).getTile(boardX, boardY); // Assert non-null, as we're within bounds\n        let tileColor;\n        if ((0, $3aec07e3cb255787$export$2e2bcd8739ae039).usingTexture) tileColor = (0, $3aec07e3cb255787$export$2e2bcd8739ae039).getPixel(boardX, boardY);\n        else tileColor = $e3d6ee63ed1479b9$var$getColorByElevation(elevation);\n        const isHighlighted = $e3d6ee63ed1479b9$var$highlightedTile && $e3d6ee63ed1479b9$var$highlightedTile.x === boardX && $e3d6ee63ed1479b9$var$highlightedTile.y === boardY || false;\n        for(let i = 0; i <= elevation; i++)$e3d6ee63ed1479b9$var$drawTile(boardX, boardY, i, tileColor, context, isHighlighted);\n    }\n}\nfunction $e3d6ee63ed1479b9$export$31a24c5a5e8c8eda() {\n    const offsetX = $e3d6ee63ed1479b9$var$canvas.width / 2;\n    const offsetY = 100;\n    $e3d6ee63ed1479b9$var$ctx.clearRect(-offsetX, -offsetY, $e3d6ee63ed1479b9$var$canvas.width, $e3d6ee63ed1479b9$var$canvas.height);\n    $e3d6ee63ed1479b9$var$drawScene($e3d6ee63ed1479b9$var$ctx);\n}\n// --- Initial setup and drawing ---\nif ($e3d6ee63ed1479b9$var$ctx) {\n    $e3d6ee63ed1479b9$var$ctx.translate($e3d6ee63ed1479b9$var$canvas.width / 2, 250);\n    $e3d6ee63ed1479b9$var$drawScene($e3d6ee63ed1479b9$var$ctx);\n} else {\n    console.error(\"Canvas not supported!\");\n    const canvasContainer = document.getElementById(\"myCanvas\");\n    canvasContainer.parentNode.replaceChild(document.createTextNode(\"Your browser does not support the canvas element.\"), canvasContainer);\n}\n\n\nconst $b6432b2dc1290172$var$Buttons = {\n    registerListeners: ()=>{\n        console.log(\"registering listeners\");\n        // --- Texture Upload and Reset Logic ---\n        const uploadButton = document.getElementById(\"uploadButton\");\n        const textureUpload = document.getElementById(\"textureUpload\");\n        const resetButton = document.getElementById(\"resetButton\");\n        uploadButton.addEventListener(\"click\", ()=>{\n            textureUpload.click(); // Trigger the file input\n        });\n        textureUpload.addEventListener(\"change\", function(event) {\n            console.log(\"upload clicked\");\n            const target = event.target;\n            const file = target.files ? target.files[0] : null; //Check for null\n            if (file && file.type === \"image/png\") {\n                const reader = new FileReader();\n                reader.onload = function(e) {\n                    if (e.target && e.target.result) {\n                        const img = new Image();\n                        img.onload = function() {\n                            (0, $3aec07e3cb255787$export$2e2bcd8739ae039).setTexture(img); // Use World object\n                            (0, $e3d6ee63ed1479b9$export$31a24c5a5e8c8eda)(); // Redraw after setting texture and board\n                        };\n                        img.src = e.target.result;\n                    }\n                };\n                reader.readAsDataURL(file);\n            } else alert(\"Please upload a PNG image.\");\n        });\n        resetButton.addEventListener(\"click\", ()=>{\n            (0, $3aec07e3cb255787$export$2e2bcd8739ae039).clearTexture(); // Use World object\n            (0, $3aec07e3cb255787$export$2e2bcd8739ae039).initializeBoard(16, 16); // Reset to original 16x16 board\n            (0, $e3d6ee63ed1479b9$export$31a24c5a5e8c8eda)(); // Redraw after resetting\n            // Reset the file input (so the same file can be selected again)\n            textureUpload.value = \"\";\n        });\n    }\n};\nvar $b6432b2dc1290172$export$2e2bcd8739ae039 = $b6432b2dc1290172$var$Buttons;\n\n\n// mouse.ts\n\n\nlet $0e9d907bb7b27674$export$2f4757dcb5d84a3a = null; // Define highlightedTile\n// --- Constants for Canvas IDs ---\nconst $0e9d907bb7b27674$export$17f9c42cae8b1dd5 = \"isometric-canvas\";\nconst $0e9d907bb7b27674$export$3b6a5aa424d54c5 = \"ortho-canvas\"; // You had this defined, but it was never used\nlet $0e9d907bb7b27674$var$activeCanvas = $0e9d907bb7b27674$export$17f9c42cae8b1dd5; // Track the currently visible canvas\nfunction $0e9d907bb7b27674$export$23bf80aa7e8177a2(orthographicEvents) {\n    if (orthographicEvents == null) throw new Error(\"orthographicEvents is null\");\n    console.log(\"initializing listeners\");\n    const canvas = document.getElementById(\"myCanvas\");\n    const TILE_WIDTH = 16; //From Render.ts\n    const TILE_HEIGHT = 8;\n    // --- Isometric Event Listener Callbacks ---\n    const isometricEvents = {\n        handleClick: (event)=>{\n            const rect = canvas.getBoundingClientRect();\n            const offsetX = canvas.width / 2;\n            const offsetY = 50;\n            const screenX = event.clientX - rect.left;\n            const screenY = event.clientY - rect.top;\n            const { x: x, y: y } = $0e9d907bb7b27674$var$screenToIso(screenX, screenY, offsetX, offsetY);\n            const boardX = Math.floor(x);\n            const boardY = Math.floor(y);\n            if (event.button === 0) (0, $3aec07e3cb255787$export$2e2bcd8739ae039).increaseElevation(boardX, boardY, event.shiftKey);\n            else if (event.button === 2) (0, $3aec07e3cb255787$export$2e2bcd8739ae039).decreaseElevation(boardX, boardY, event.shiftKey);\n            (0, $e3d6ee63ed1479b9$export$31a24c5a5e8c8eda)();\n        },\n        handleMouseMove: (event)=>{\n            const rect = canvas.getBoundingClientRect();\n            const offsetX = canvas.width / 2;\n            const offsetY = 50; // Consistent offset with drawScene\n            const screenX = event.clientX - rect.left;\n            const screenY = event.clientY - rect.top;\n            const { x: x, y: y } = $0e9d907bb7b27674$var$screenToIso(screenX, screenY, offsetX, offsetY);\n            const boardX = Math.floor(x);\n            const boardY = Math.floor(y);\n            if ($0e9d907bb7b27674$export$2f4757dcb5d84a3a === null || $0e9d907bb7b27674$export$2f4757dcb5d84a3a.x !== boardX || $0e9d907bb7b27674$export$2f4757dcb5d84a3a.y !== boardY) {\n                $0e9d907bb7b27674$export$2f4757dcb5d84a3a = {\n                    x: boardX,\n                    y: boardY\n                };\n                (0, $e3d6ee63ed1479b9$export$31a24c5a5e8c8eda)(); // Redraw on *every* mouse move that changes the highlighted tile\n            }\n        },\n        handleMouseOut: (event)=>{\n            $0e9d907bb7b27674$export$2f4757dcb5d84a3a = null;\n            (0, $e3d6ee63ed1479b9$export$31a24c5a5e8c8eda)();\n        },\n        handleKeyDown: (event)=>{\n            if (event.key === 'r') {\n                (0, $3aec07e3cb255787$export$2e2bcd8739ae039).rotateWorld(event.shiftKey);\n                (0, $e3d6ee63ed1479b9$export$31a24c5a5e8c8eda)();\n            }\n        }\n    };\n    // --- Generic Event Listeners ---\n    document.addEventListener('click', function(event) {\n        const mouseEvent = event;\n        if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$17f9c42cae8b1dd5) isometricEvents.handleClick(mouseEvent);\n        else if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$3b6a5aa424d54c5) orthographicEvents.handleClick(mouseEvent);\n    });\n    document.addEventListener('contextmenu', function(event) {\n        const mouseEvent = event;\n        event.preventDefault(); // Prevent default context menu\n        if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$17f9c42cae8b1dd5) isometricEvents.handleClick(mouseEvent); //Reuse the same handler.\n        else if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$3b6a5aa424d54c5) orthographicEvents.handleClick(mouseEvent);\n    });\n    document.addEventListener('mousemove', function(event) {\n        const mouseEvent = event;\n        if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$17f9c42cae8b1dd5) isometricEvents.handleMouseMove(mouseEvent);\n        else if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$3b6a5aa424d54c5) orthographicEvents.handleMouseMove(mouseEvent);\n    });\n    document.addEventListener(\"mouseout\", function(event) {\n        const mouseEvent = event;\n        if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$17f9c42cae8b1dd5) isometricEvents.handleMouseOut(mouseEvent);\n        else if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$3b6a5aa424d54c5) orthographicEvents.handleMouseOut(mouseEvent);\n    });\n    document.addEventListener(\"keydown\", function(event) {\n        const keyboardEvent = event;\n        if (keyboardEvent.key === '`' || keyboardEvent.code === 'Backquote' || keyboardEvent.keyCode === 192) {\n            console.log(\"switching canvas\");\n            event.preventDefault(); // Prevent default tab behavior (focus change)\n            $0e9d907bb7b27674$export$9d3078951cd0fca2((0, $e3d6ee63ed1479b9$export$31a24c5a5e8c8eda), ()=>{\n                orthographicEvents.onDisplay();\n            });\n            return;\n        }\n        if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$17f9c42cae8b1dd5) isometricEvents.handleKeyDown(keyboardEvent);\n        else if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$3b6a5aa424d54c5) orthographicEvents.handleKeyDown(keyboardEvent);\n    });\n}\nfunction $0e9d907bb7b27674$var$screenToIso(screenX, screenY, offsetX, offsetY) {\n    const isoX = screenX - offsetX;\n    const isoY = screenY - offsetY;\n    const boardX = (isoX / ((0, $e3d6ee63ed1479b9$export$e11fadbd198f646b) / 2) + isoY / ((0, $e3d6ee63ed1479b9$export$fc29bff6b348510e) / 2)) / 2;\n    const boardY = (isoY / ((0, $e3d6ee63ed1479b9$export$fc29bff6b348510e) / 2) - isoX / ((0, $e3d6ee63ed1479b9$export$e11fadbd198f646b) / 2)) / 2;\n    return {\n        x: boardX,\n        y: boardY\n    };\n}\nfunction $0e9d907bb7b27674$export$9d3078951cd0fca2(onIsoSelected, onOrthoSelected) {\n    const isoCanvas = document.getElementById($0e9d907bb7b27674$export$17f9c42cae8b1dd5);\n    const orthoCanvas = document.getElementById($0e9d907bb7b27674$export$3b6a5aa424d54c5); //Corrected\n    if ($0e9d907bb7b27674$var$activeCanvas === $0e9d907bb7b27674$export$17f9c42cae8b1dd5) {\n        isoCanvas.style.display = \"none\";\n        if (orthoCanvas) orthoCanvas.style.display = \"block\"; //Corrected\n        $0e9d907bb7b27674$var$activeCanvas = $0e9d907bb7b27674$export$3b6a5aa424d54c5;\n        onOrthoSelected();\n    } else {\n        if (orthoCanvas) orthoCanvas.style.display = \"none\"; //Corrected\n        isoCanvas.style.display = \"block\";\n        $0e9d907bb7b27674$var$activeCanvas = $0e9d907bb7b27674$export$17f9c42cae8b1dd5;\n        onIsoSelected();\n    }\n}\n\n\n\n\n(0, $b6432b2dc1290172$export$2e2bcd8739ae039).registerListeners(); // Register button listeners\n\n\n//# sourceMappingURL=index.4b4613f2.js.map\n","// src/index.ts\r\nimport './buttons'; // Import buttons to ensure it runs\r\nimport Buttons from './buttons';\r\nimport './mouse';   // Import mouse to ensure it runs\r\nimport './render';  // Import render to ensure it runs\r\nimport './world';   // Import world to ensure it runs\r\n\r\n\r\nButtons.registerListeners(); // Register button listeners\r\n","import World from \"./world\";\r\nimport { redrawScene } from \"./render\";\r\n\r\nconst Buttons = {\r\n    registerListeners: () => {\r\n        console.log(\"registering listeners\");\r\n        // --- Texture Upload and Reset Logic ---\r\n        const uploadButton = document.getElementById(\"uploadButton\") as HTMLButtonElement;\r\n        const textureUpload = document.getElementById(\"textureUpload\") as HTMLInputElement;\r\n        const resetButton = document.getElementById(\"resetButton\") as HTMLButtonElement;\r\n\r\n        uploadButton.addEventListener(\"click\", () => {\r\n            textureUpload.click(); // Trigger the file input\r\n        });\r\n\r\n        textureUpload.addEventListener(\"change\", function(event: Event) {\r\n            console.log(\"upload clicked\");\r\n            const target = event.target as HTMLInputElement;\r\n            const file = target.files ? target.files[0] : null;  //Check for null\r\n            if (file && file.type === \"image/png\") {\r\n                const reader = new FileReader();\r\n                reader.onload = function(e: ProgressEvent<FileReader>) {\r\n                  if (e.target && e.target.result) { //Check that result is not null\r\n                    const img = new Image();\r\n                    img.onload = function() {\r\n                        World.setTexture(img); // Use World object\r\n                        redrawScene(); // Redraw after setting texture and board\r\n                    };\r\n                    img.src = e.target.result as string;\r\n                  }\r\n                };\r\n                reader.readAsDataURL(file);\r\n            } else {\r\n                alert(\"Please upload a PNG image.\");\r\n            }\r\n        });\r\n\r\n        resetButton.addEventListener(\"click\", () => {\r\n            World.clearTexture(); // Use World object\r\n            World.initializeBoard(16, 16); // Reset to original 16x16 board\r\n            redrawScene(); // Redraw after resetting\r\n\r\n            // Reset the file input (so the same file can be selected again)\r\n            textureUpload.value = \"\";\r\n        });\r\n    }\r\n};\r\n\r\nexport default Buttons;","// World.ts\r\ninterface TileCoordinates {\r\n    x: number;\r\n    y: number;\r\n}\r\nconst World = {\r\n    board: [] as number[][],  // 2D array of numbers (elevations)\r\n    textureCanvas: null as HTMLCanvasElement | null,\r\n    textureCtx: null as CanvasRenderingContext2D | null,\r\n    usingTexture: false,\r\n\r\n    initializeBoard(width: number, height: number): void {\r\n        this.board = [];\r\n        for (let y = 0; y < height; y++) {\r\n            let row: number[] = [];\r\n            for (let x = 0; x < width; x++) {\r\n                row.push(0); // Initialize all elevations to 0\r\n            }\r\n            this.board.push(row);\r\n        }\r\n    },\r\n\r\n    getTile(boardX: number, boardY: number): number | null {\r\n        if (boardX >= 0 && boardX < this.board[0].length && boardY >= 0 && boardY < this.board.length) {\r\n            return this.board[boardY][boardX];\r\n        }\r\n        return null; // Or handle out-of-bounds differently\r\n    },\r\n\r\n    setTile(boardX: number, boardY: number, elevation: number): void {\r\n        if (boardX >= 0 && boardX < this.board[0].length && boardY >= 0 && boardY < this.board.length) {\r\n            this.board[boardY][boardX] = elevation;\r\n        }\r\n    },\r\n\r\n    getPixel(boardX: number, boardY: number): string {\r\n        if (!this.textureCtx) {\r\n            return \"#000000\"; // Default color if no texture\r\n        }\r\n\r\n        let texX = boardX;\r\n        let texY = boardY;\r\n\r\n        // Bounds Check\r\n        if (texX < 0 || texX >= this.textureCanvas!.width || texY < 0 || texY >= this.textureCanvas!.height) {\r\n            return \"#000000\"; //Return black if out of bounds.\r\n        }\r\n\r\n        const pixelData = this.textureCtx.getImageData(texX, texY, 1, 1).data;\r\n        return `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;\r\n    },\r\n    setTexture(img: HTMLImageElement): void {\r\n        this.textureCanvas = document.createElement(\"canvas\");\r\n        this.textureCanvas.width = img.width;\r\n        this.textureCanvas.height = img.height;\r\n        this.textureCtx = this.textureCanvas.getContext(\"2d\")!; // Assert non-null\r\n        this.textureCtx.drawImage(img, 0, 0);\r\n        this.usingTexture = true;\r\n        this.initializeBoard(img.width, img.height);\r\n\r\n    },\r\n    clearTexture(): void {\r\n        this.usingTexture = false;\r\n        this.textureCanvas = null;\r\n        this.textureCtx = null;\r\n    },\r\n    getWidth(): number {\r\n        return this.board[0].length;\r\n    },\r\n    getHeight(): number {\r\n        return this.board.length;\r\n    },\r\n    increaseElevation(boardX: number, boardY: number, bulkEdit: boolean): void {\r\n        if (boardX >= 0 && boardX < this.getWidth() && boardY >= 0 && boardY < this.getHeight()) {\r\n            if (bulkEdit && this.usingTexture) {\r\n                const targetColor = this.getPixel(boardX, boardY);\r\n                for (let y = 0; y < this.getHeight(); y++) {\r\n                    for (let x = 0; x < this.getWidth(); x++) {\r\n                        if (this.getPixel(x, y) === targetColor) {\r\n                            this.setTile(x, y, Math.max(0, this.getTile(x, y)! + 1)); // Assert non-null\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                this.setTile(boardX, boardY, Math.max(0, this.getTile(boardX, boardY)! + 1)); // Assert non-null\r\n            }\r\n        }\r\n    },\r\n\r\n    decreaseElevation(boardX: number, boardY: number, bulkEdit: boolean): void {\r\n        if (boardX >= 0 && boardX < this.getWidth() && boardY >= 0 && boardY < this.getHeight()) {\r\n            if (bulkEdit && this.usingTexture) {\r\n                const targetColor = this.getPixel(boardX, boardY);\r\n                for (let y = 0; y < this.getHeight(); y++) {\r\n                    for (let x = 0; x < this.getWidth(); x++) {\r\n                        if (this.getPixel(x, y) === targetColor) {\r\n                            this.setTile(x, y, Math.max(0, this.getTile(x, y)! - 1)); // Assert non-null\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                this.setTile(boardX, boardY, Math.max(0, this.getTile(boardX, boardY)! - 1)); // Assert non-null\r\n            }\r\n        }\r\n    },\r\n\r\n    rotateWorld(counterClockwise: boolean = false): void {\r\n        // --- Rotate Texture (if using texture) ---\r\n        if (this.usingTexture && this.textureCanvas) {\r\n            const rotatedCanvas = document.createElement('canvas');\r\n            rotatedCanvas.width = this.textureCanvas.height;  // Swap width/height\r\n            rotatedCanvas.height = this.textureCanvas.width;\r\n            const rotatedCtx = rotatedCanvas.getContext('2d')!; // Assert non-null\r\n\r\n            rotatedCtx.clearRect(0, 0, rotatedCanvas.width, rotatedCanvas.height); //Clear\r\n            if (counterClockwise) {\r\n                rotatedCtx.rotate(-Math.PI / 2);\r\n                rotatedCtx.drawImage(this.textureCanvas, -this.textureCanvas.width, 0);\r\n\r\n            }\r\n            else {\r\n                rotatedCtx.rotate(Math.PI / 2);\r\n                rotatedCtx.drawImage(this.textureCanvas, 0, -this.textureCanvas.height);\r\n            }\r\n\r\n            this.textureCanvas = rotatedCanvas; // Replace the old canvas\r\n            this.textureCtx = rotatedCtx;\r\n        }\r\n          // --- Rotate Board ---\r\n        let newBoard: number[][];\r\n        if(!counterClockwise){\r\n            newBoard = this.board[0].map((val, index) => this.board.map(row => row[index]).reverse());\r\n        }\r\n        else{\r\n            newBoard = this.board[0].map((val, index) => this.board.map(row => row[row.length-1-index]));\r\n        }\r\n        this.board = newBoard; // Assign the new board\r\n    }\r\n};\r\n\r\n//Initial 16x16 board at startup\r\nWorld.initializeBoard(16,16);\r\n\r\nexport default World;","// render.ts\r\nimport World from \"./world\";\r\n\r\nexport const TILE_WIDTH = 16;\r\nexport const TILE_HEIGHT = 8;\r\n\r\nconst canvas = document.getElementById(\"myCanvas\") as HTMLCanvasElement;\r\nconst ctx = canvas.getContext(\"2d\")!; // Assert non-null, checked below\r\n\r\ninterface TileCoordinates {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\n// Assuming highlightedTile is defined and managed in mouse.ts,\r\n// we'll declare it here with the correct type.  It's important\r\n// that this matches the type in mouse.ts.\r\nlet highlightedTile: TileCoordinates | null = null;  //From Mouse.js\r\n\r\n\r\nfunction getColorByElevation(elevation: number): string {\r\n    switch (elevation) {\r\n        case 0: return \"#0000ff\"; // blue (water)\r\n        case 1: return \"#ffff00\"; // yellow (sandy)\r\n        case 2:\r\n        case 3: return \"#00c800\"; // green (grass)\r\n        case 4:\r\n        case 5: return \"#808080\"; // gray (mountain)\r\n        case 6: return \"#ffffff\"; // white (snow)\r\n        default: return \"#808080\";\r\n    }\r\n}\r\ninterface Vertices {\r\n    v1x: number;\r\n    v1y: number;\r\n    v2x: number;\r\n    v2y: number;\r\n    v3x: number;\r\n    v3y: number;\r\n    v4x: number;\r\n    v4y: number;\r\n    v5y: number;\r\n    v6y: number;\r\n    v7y: number;\r\n}\r\n\r\nfunction tileVertices(boardX: number, boardY: number, zHeight: number): Vertices {\r\n    const isoX = (boardX - boardY) * TILE_WIDTH / 2;\r\n    const isoY = (boardX + boardY) * TILE_HEIGHT / 2;\r\n    const topOffsetY = -zHeight * TILE_HEIGHT;\r\n\r\n    return {\r\n        v1x: isoX,\r\n        v1y: isoY + topOffsetY,\r\n        v2x: isoX + TILE_WIDTH / 2,\r\n        v2y: isoY + TILE_HEIGHT / 2 + topOffsetY,\r\n        v3x: isoX,\r\n        v3y: isoY + TILE_HEIGHT + topOffsetY,\r\n        v4x: isoX - TILE_WIDTH / 2,\r\n        v4y: isoY + TILE_HEIGHT / 2 + topOffsetY,\r\n        v5y: isoY + TILE_HEIGHT, // Used for left/right faces\r\n        v6y: isoY + TILE_HEIGHT / 2,  //bottom left\r\n        v7y: isoY + TILE_HEIGHT / 2, //bottom right\r\n    };\r\n}\r\n\r\n\r\nfunction drawTile(boardX: number, boardY: number, zHeight: number, color: string, context: CanvasRenderingContext2D, isHighlighted: boolean): void {\r\n    const { v1x, v1y, v2x, v2y, v3x, v3y, v4x, v4y, v5y, v6y, v7y } = tileVertices(boardX, boardY, zHeight);\r\n\r\n\r\n    let drawColor = color;\r\n    if (isHighlighted) {\r\n        drawColor = adjustBrightness(color, 0.2); // Brighten for highlight\r\n    }\r\n\r\n    // --- Top Face ---\r\n    context.fillStyle = drawColor;\r\n    tilePath(context, v1x, v1y, v2x, v2y, v3x, v3y, v4x, v4y);\r\n    context.fill();\r\n\r\n\r\n    // --- Left & Right Faces (only if zHeight > 0) ---\r\n    if (zHeight > 0) {\r\n        // --- Left Face ---\r\n        context.fillStyle = adjustBrightness(drawColor, -0.2);\r\n        context.beginPath();\r\n        context.moveTo(v4x, v4y);\r\n        context.lineTo(v3x, v3y);\r\n        context.lineTo(v1x, v5y);\r\n        context.lineTo(v4x, v6y);\r\n        context.closePath();\r\n        context.fill();\r\n\r\n        // --- Right Face ---\r\n        context.fillStyle = adjustBrightness(drawColor, -0.4);\r\n        context.beginPath();\r\n        context.moveTo(v2x, v2y);\r\n        context.lineTo(v3x, v3y);\r\n        context.lineTo(v1x, v5y);\r\n        context.lineTo(v2x, v7y);\r\n        context.closePath();\r\n        context.fill();\r\n    }\r\n}\r\n\r\nfunction tilePath(context: CanvasRenderingContext2D, v1x: number, v1y: number, v2x: number, v2y: number, v3x: number, v3y: number, v4x: number, v4y: number): void {\r\n    context.beginPath();\r\n    context.moveTo(v1x, v1y);\r\n    context.lineTo(v2x, v2y);\r\n    context.lineTo(v3x, v3y);\r\n    context.lineTo(v4x, v4y);\r\n    context.closePath();\r\n}\r\n\r\n\r\nfunction adjustBrightness(color: string, amount: number): string {\r\n    // Handle rgb() colors\r\n    if (color.startsWith(\"rgb\")) {\r\n        let [r, g, b] = color.substring(4, color.length - 1).split(\",\").map(Number);\r\n\r\n        r = Math.min(255, Math.max(0, Math.round(r + amount * 255)));\r\n        g = Math.min(255, Math.max(0, Math.round(g + amount * 255)));\r\n        b = Math.min(255, Math.max(0, Math.round(b + amount * 255)));\r\n\r\n        return `rgb(${r}, ${g}, ${b})`;\r\n    }\r\n    //Handle hex\r\n    let usePound = false;\r\n    if (color[0] == \"#\") {\r\n        color = color.slice(1);\r\n        usePound = true;\r\n    }\r\n\r\n    let num = parseInt(color, 16);\r\n    let r = (num >> 16) + amount * 255;\r\n    if (r > 255) r = 255;\r\n    else if (r < 0) r = 0;\r\n    let b = ((num >> 8) & 0x00FF) + amount * 255;\r\n    if (b > 255) b = 255;\r\n    else if (b < 0) b = 0;\r\n    let g = (num & 0x0000FF) + amount * 255;\r\n    if (g > 255) g = 255;\r\n    else if (g < 0) g = 0;\r\n\r\n    let newColor = (g | (b << 8) | (r << 16)).toString(16);\r\n\r\n    while (newColor.length < 6) {\r\n        newColor = \"0\" + newColor;\r\n    }\r\n\r\n    return (usePound ? \"#\" : \"\") + newColor;\r\n\r\n}\r\n\r\nfunction screenToIso(screenX: number, screenY: number, offsetX: number, offsetY: number): TileCoordinates {\r\n    const isoX = screenX - offsetX;\r\n    const isoY = screenY - offsetY;\r\n\r\n    const boardX = (isoX / (TILE_WIDTH / 2) + isoY / (TILE_HEIGHT / 2)) / 2;\r\n    const boardY = (isoY / (TILE_HEIGHT / 2) - isoX / (TILE_WIDTH / 2)) / 2;\r\n    return { x: boardX, y: boardY };\r\n}\r\n\r\n\r\nfunction drawScene(context: CanvasRenderingContext2D): void {\r\n    const offsetX = canvas.width / 2;\r\n    const offsetY = 50;\r\n\r\n    for (let boardY = 0; boardY < World.getHeight(); boardY++) {\r\n        for (let boardX = 0; boardX < World.getWidth(); boardX++) {\r\n            const elevation = World.getTile(boardX, boardY)!; // Assert non-null, as we're within bounds\r\n            let tileColor: string;\r\n\r\n            if (World.usingTexture) {\r\n                tileColor = World.getPixel(boardX, boardY);\r\n            } else {\r\n                tileColor = getColorByElevation(elevation);\r\n            }\r\n\r\n            const isHighlighted: boolean = (highlightedTile &&\r\n                highlightedTile.x === boardX &&\r\n                highlightedTile.y === boardY) || false;\r\n\r\n            for (let i = 0; i <= elevation; i++) {\r\n                drawTile(boardX, boardY, i, tileColor, context, isHighlighted);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function redrawScene(): void {\r\n    const offsetX = canvas.width / 2;\r\n    const offsetY = 100;\r\n    ctx.clearRect(-offsetX, -offsetY, canvas.width, canvas.height);\r\n    drawScene(ctx);\r\n}\r\n\r\n// --- Initial setup and drawing ---\r\nif (ctx) {\r\n    ctx.translate(canvas.width / 2, 250);\r\n    drawScene(ctx);\r\n} else {\r\n    console.error(\"Canvas not supported!\");\r\n    const canvasContainer = document.getElementById(\"myCanvas\") as HTMLCanvasElement;\r\n    canvasContainer.parentNode!.replaceChild( // Assert non-null\r\n        document.createTextNode(\"Your browser does not support the canvas element.\"),\r\n        canvasContainer\r\n    );\r\n}","// mouse.ts\r\nimport World from \"./world\";\r\nimport { redrawScene, TILE_WIDTH, TILE_HEIGHT } from \"./render\"; // Import constants\r\n\r\n\r\ninterface TileCoordinates {\r\n  x: number;\r\n  y: number;\r\n}\r\nlet highlightedTile: TileCoordinates | null = null; // Define highlightedTile\r\n\r\n// --- Constants for Canvas IDs ---\r\nconst ISOMETRIC_CANVAS = \"isometric-canvas\";\r\nconst ORTHOGRAPHIC_CANVAS = \"ortho-canvas\"; // You had this defined, but it was never used\r\nlet activeCanvas = ISOMETRIC_CANVAS; // Track the currently visible canvas\r\n\r\ninterface CanvasEventHandlers {\r\n  handleClick: (event: MouseEvent) => void;\r\n  handleMouseMove: (event: MouseEvent) => void;\r\n  handleMouseOut: (event: MouseEvent) => void;\r\n  handleKeyDown: (event: KeyboardEvent) => void;\r\n  onDisplay?: () => void;\r\n}\r\n\r\nfunction initializeListeners(orthographicEvents: CanvasEventHandlers) {\r\n\r\n    if (orthographicEvents == null) {\r\n        throw new Error(\"orthographicEvents is null\");\r\n    }\r\n\r\n    console.log(\"initializing listeners\");\r\n\r\n  const canvas = document.getElementById(\"myCanvas\") as HTMLCanvasElement;\r\n  const TILE_WIDTH = 16; //From Render.ts\r\n  const TILE_HEIGHT = 8;\r\n\r\n    // --- Isometric Event Listener Callbacks ---\r\n  const isometricEvents: CanvasEventHandlers = {\r\n\r\n    handleClick: (event: MouseEvent) => {\r\n    const rect = canvas.getBoundingClientRect();\r\n    const offsetX = canvas.width / 2;\r\n    const offsetY = 50;\r\n\r\n    const screenX = event.clientX - rect.left;\r\n    const screenY = event.clientY - rect.top;\r\n\r\n      const { x, y } = screenToIso(screenX, screenY, offsetX, offsetY);\r\n      const boardX = Math.floor(x);\r\n      const boardY = Math.floor(y);\r\n\r\n    if (event.button === 0) { // Left click\r\n        World.increaseElevation(boardX, boardY, event.shiftKey);\r\n    } else if (event.button === 2) { // Right click\r\n       World.decreaseElevation(boardX, boardY, event.shiftKey);\r\n    }\r\n      redrawScene();\r\n    },\r\n\r\n    handleMouseMove: (event: MouseEvent) => {\r\n      const rect = canvas.getBoundingClientRect();\r\n      const offsetX = canvas.width / 2;\r\n    const offsetY = 50; // Consistent offset with drawScene\r\n\r\n    const screenX = event.clientX - rect.left;\r\n    const screenY = event.clientY - rect.top;\r\n      const { x, y } = screenToIso(screenX, screenY, offsetX, offsetY);\r\n    const boardX = Math.floor(x);\r\n    const boardY = Math.floor(y);\r\n      if (highlightedTile === null || highlightedTile.x !== boardX || highlightedTile.y !== boardY) {\r\n        highlightedTile = { x: boardX, y: boardY };\r\n        redrawScene(); // Redraw on *every* mouse move that changes the highlighted tile\r\n      }\r\n    },\r\n    handleMouseOut: (event: MouseEvent) => {\r\n      highlightedTile = null;\r\n      redrawScene();\r\n    },\r\n    handleKeyDown: (event: KeyboardEvent) => {\r\n      if (event.key === 'r' ) {\r\n        World.rotateWorld(event.shiftKey);\r\n        redrawScene();\r\n      }\r\n    }\r\n  }\r\n\r\n    // --- Generic Event Listeners ---\r\n    document.addEventListener('click', function(event: MouseEvent) {\r\n      const mouseEvent = event as MouseEvent;\r\n        if (activeCanvas === ISOMETRIC_CANVAS) {\r\n            isometricEvents.handleClick(mouseEvent);\r\n        } else if (activeCanvas === ORTHOGRAPHIC_CANVAS) {\r\n            orthographicEvents.handleClick(mouseEvent);\r\n        }\r\n    });\r\n\r\n    document.addEventListener('contextmenu', function(event: MouseEvent) {\r\n      const mouseEvent = event as MouseEvent;\r\n        event.preventDefault(); // Prevent default context menu\r\n        if (activeCanvas === ISOMETRIC_CANVAS) {\r\n            isometricEvents.handleClick(mouseEvent); //Reuse the same handler.\r\n        } else if (activeCanvas === ORTHOGRAPHIC_CANVAS) {\r\n            orthographicEvents.handleClick(mouseEvent);\r\n        }\r\n    });\r\n\r\n    document.addEventListener('mousemove', function(event: MouseEvent) {\r\n      const mouseEvent = event as MouseEvent;\r\n        if (activeCanvas === ISOMETRIC_CANVAS) {\r\n            isometricEvents.handleMouseMove(mouseEvent);\r\n        } else if (activeCanvas === ORTHOGRAPHIC_CANVAS) {\r\n            orthographicEvents.handleMouseMove(mouseEvent);\r\n        }\r\n    });\r\n\r\n    document.addEventListener(\"mouseout\", function(event: MouseEvent) {\r\n      const mouseEvent = event as MouseEvent;\r\n        if (activeCanvas === ISOMETRIC_CANVAS) {\r\n            isometricEvents.handleMouseOut(mouseEvent);\r\n        } else if (activeCanvas === ORTHOGRAPHIC_CANVAS) {\r\n            orthographicEvents.handleMouseOut(mouseEvent);\r\n        }\r\n    });\r\n\r\n    document.addEventListener(\"keydown\", function(event: KeyboardEvent) {\r\n      const keyboardEvent = event as KeyboardEvent;\r\n        if (keyboardEvent.key === '`' || keyboardEvent.code === 'Backquote' || keyboardEvent.keyCode === 192) {\r\n            console.log(\"switching canvas\");\r\n            event.preventDefault(); // Prevent default tab behavior (focus change)\r\n            toggleCanvas(redrawScene, ()=>{ orthographicEvents.onDisplay!();});\r\n            return;\r\n        }\r\n\r\n        if (activeCanvas === ISOMETRIC_CANVAS) {\r\n            isometricEvents.handleKeyDown(keyboardEvent);\r\n        } else if (activeCanvas === ORTHOGRAPHIC_CANVAS) {\r\n            orthographicEvents.handleKeyDown(keyboardEvent);\r\n        }\r\n    });\r\n}\r\nfunction screenToIso(screenX: number, screenY: number, offsetX: number, offsetY: number): TileCoordinates {\r\n  const isoX = screenX - offsetX;\r\n  const isoY = screenY - offsetY;\r\n\r\n  const boardX = (isoX / (TILE_WIDTH / 2) + isoY / (TILE_HEIGHT / 2)) / 2;\r\n  const boardY = (isoY / (TILE_HEIGHT / 2) - isoX / (TILE_WIDTH / 2)) / 2;\r\n  return {x: boardX, y: boardY};\r\n}\r\n\r\n\r\n\r\nfunction toggleCanvas(onIsoSelected: () => void, onOrthoSelected: () => void) {\r\n    const isoCanvas = document.getElementById(ISOMETRIC_CANVAS) as HTMLCanvasElement;\r\n    const orthoCanvas = document.getElementById(ORTHOGRAPHIC_CANVAS) as HTMLCanvasElement; //Corrected\r\n\r\n    if (activeCanvas === ISOMETRIC_CANVAS) {\r\n        isoCanvas.style.display = \"none\";\r\n        if(orthoCanvas) orthoCanvas.style.display = \"block\"; //Corrected\r\n        activeCanvas = ORTHOGRAPHIC_CANVAS;\r\n        onOrthoSelected();\r\n    } else {\r\n        if(orthoCanvas) orthoCanvas.style.display = \"none\";  //Corrected\r\n        isoCanvas.style.display = \"block\";\r\n        activeCanvas = ISOMETRIC_CANVAS;\r\n        onIsoSelected();\r\n\r\n    }\r\n}\r\n\r\nexport { initializeListeners, toggleCanvas, TileCoordinates, highlightedTile, ISOMETRIC_CANVAS, ORTHOGRAPHIC_CANVAS };"],"names":["$3aec07e3cb255787$var$World","board","textureCanvas","textureCtx","usingTexture","initializeBoard","width","height","y","row","x","push","getTile","boardX","boardY","length","setTile","elevation","getPixel","texX","texY","pixelData","getImageData","data","setTexture","img","document","createElement","getContext","drawImage","clearTexture","getWidth","getHeight","increaseElevation","bulkEdit","targetColor","Math","max","decreaseElevation","rotateWorld","counterClockwise","newBoard","rotatedCanvas","rotatedCtx","clearRect","rotate","PI","map","val","index","reverse","$e3d6ee63ed1479b9$var$canvas","getElementById","$e3d6ee63ed1479b9$var$ctx","$e3d6ee63ed1479b9$var$adjustBrightness","color","amount","startsWith","r","g","b","substring","split","Number","min","round","usePound","slice","num","parseInt","newColor","toString","$e3d6ee63ed1479b9$var$drawScene","context","tileColor","$e3d6ee63ed1479b9$var$getColorByElevation","i","$e3d6ee63ed1479b9$var$drawTile","zHeight","isHighlighted","v1x","v1y","v2x","v2y","v3x","v3y","v4x","v4y","v5y","v6y","v7y","$e3d6ee63ed1479b9$var$tileVertices","isoX","isoY","topOffsetY","$e3d6ee63ed1479b9$export$e11fadbd198f646b","$e3d6ee63ed1479b9$export$fc29bff6b348510e","drawColor","fillStyle","beginPath","moveTo","lineTo","closePath","fill","$e3d6ee63ed1479b9$export$31a24c5a5e8c8eda","offsetX","translate","console","error","canvasContainer","parentNode","replaceChild","createTextNode","registerListeners","log","uploadButton","textureUpload","resetButton","addEventListener","click","event","target","file","files","type","reader","FileReader","onload","e","result","Image","src","readAsDataURL","alert","value"],"version":3,"file":"index.4b4613f2.js.map"}